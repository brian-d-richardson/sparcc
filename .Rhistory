FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
}
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat[z + 1, "shape1"],
shape2 = x.params.hat[z + 1, "shape2"])
}
## estimated parameters for C|Z
if (c.correct) {
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
}
library(dplyr)
## estimated parameters for X|Z
if (x.correct) {
x.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
}
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat[z + 1, "shape1"],
shape2 = x.params.hat[z + 1, "shape2"])
}
## estimated parameters for C|Z
if (c.correct) {
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
}
## X|Z quadrature nodes
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
## X|Z quadrature weights
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) /
sum(eta1(x.nds[,i], zs[i])))
x.params.hat
x.correct
## estimated parameters for X|Z
x.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
x.params.hat
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat[z + 1, "shape1"],
shape2 = x.params.hat[z + 1, "shape2"])
}
## estimated parameters for X|Z
x.fit <- dat %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
x.fit
x.params.hat <- x.fit$estimate
x.params.hat
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat$shape1,
shape2 = x.params.hat$shape2)
}
## estimated parameters for C|Z
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
## estimated density of C|Z
eta2.correct <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat.correct[z + 1, "shape1"],
shape2 = c.params.hat.correct[z + 1, "shape2"])
}
## estimated density of C|Z
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
## X|Z quadrature nodes
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
## X|Z quadrature weights
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) /
sum(eta1(x.nds[,i], zs[i])))
i = 1
eta1(x.nds[,i], zs[i])
x.params.hat
x.fit$estimate
x.params.hat$shape1
x.params.hat["shape1"]
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat["shape1"],
shape2 = x.params.hat["shape2"])
}
## estimated parameters for C|Z
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
## estimated density of C|Z
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
## X|Z quadrature nodes
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
## X|Z quadrature weights
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) /
sum(eta1(x.nds[,i], zs[i])))
# Y quadrature
gq <- statmod::gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
# complete case lm to get starting value
naive.lm <- lm(Y ~ W, data = datcc)
# complete case
Bcc <- get.root(dat = dat, score = get.Scc,
start = c(naive.lm$coef, log(var(naive.lm$resid))))
# oracle
B0 <- get.root(dat = dat0, score = get.Scc,
start = Bcc)
# MLE
Bmle <- get.root(dat = dat, score = get.Sml, start = Bcc,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts))
# semiparametric efficient score
Beff <- get.root(dat = dat, score = get.Seff, start = Bcc,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
eta1 = eta1,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts))
Beff
Bcc
## complete case linear model to get starting value
naive.lm <- lm(Y ~ W + Z, data = datcc)
## complete case
B.cc <- get.root(dat = dat, score = get.Scc,
start = c(naive.lm$coef, log(var(naive.lm$resid))))
B.cc
## oracle
B.or <- get.root(dat = dat0, score = get.Scc, start = B.cc)
## MLE (X|Z correct)
mle.args <- list(x.nds = x.nds)
B.ml.1 <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = append(mle.args, list("x.wts" = x.wts.correct)))
B.ml.1
## MLE (X|Z correct)
mle.args <- list(mu = mu, d.mu = d.mu, SF = SF, fy = fy, x.nds = x.nds)
B.ml.1 <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = append(mle.args, list("x.wts" = x.wts.correct)))
B.ml.1
## MLE (X|Z correct)
mle.args <- list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts)
B.ml.1 <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
## MLE (X|Z correct)
mle.args <- list(x.nds = x.nds, x.wts = x.wts)
B.mle <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
B.mle
round(B.cc, 2)
## complete case linear model to get starting value
naive.lm <- lm(Y ~ W + Z, data = datcc)
## complete case
B.cc <- get.root(dat = dat, score = get.Scc,
start = c(naive.lm$coef, log(var(naive.lm$resid))))
round(B.cc, 2)
## oracle
B.or <- get.root(dat = dat0, score = get.Scc, start = B.cc)
round(B.or, 2)
## MLE (X|Z correct)
mle.args <- list(x.nds = x.nds, x.wts = x.wts)
B.mle <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
round(B.mle, 2)
## semiparametric efficient estimator
sp.args <- list(x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts)
c.nds
## Y|X,Z quadrature
gq <- statmod::gauss.quad(n = my, kind = "hermite")
## C|Z quadrature nodes
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mc),
FUN = function(z) seq(1E-6, 1-1E-6, length = mc))
## X|Z quadrature weights
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mc),
FUN = function(i) eta2(c.nds[,i], zs[i]) /
sum(eta2(c.nds[,i], zs[i])))
## semiparametric efficient estimator
sp.args <- list(x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts)
B.sp <- get.root(dat = dat, score = get.Seff, start = B.cc,
args = sp.args)
B.sp
round(B.sp, 2)
# compare estimates
rbind(c(B, log(s2)), B0, Bcc, Bmle, Beff)
c(B, log(s2))
# compare estimates
rbind(c(B, log(s2)), B.or, B.cc, B.mle, B.sp)
# compare estimates
round(rbind(c(B, log(s2)), B.or, B.cc, B.mle, B.sp), 2)
# load the package
library(sparcc)
# other necessary packages
library(conf)
library(dplyr)
# define parameters -------------------------------------------------------
set.seed(1)                   # random number seed for reproducibility
B <- c(1, 10, 2)              # outcome model parameters
s2 <- 1                       # Var(Y|X,Z)
x.thetas <- 0.5 * c(-1, 1)    # parameters governing X|Z and C|Z
x.gamma <- 1
c.gamma <- 2
mx <- 40                      # number of nodes in quadrature grid for X|Z
mc <- 40                      # number of nodes in quadrature grid for C|Z
my <- 5                       # number of nodes in quadrature grid for Y|X,Z
# load the package
library(sparcc)
# other necessary packages
library(dplyr)
# define parameters -------------------------------------------------------
set.seed(1)                   # random number seed for reproducibility
B <- c(1, 10, 2)              # outcome model parameters
s2 <- 1                       # Var(Y|X,Z)
x.thetas <- 0.5 * c(-1, 1)    # parameters governing X|Z and C|Z
x.gamma <- 1
c.gamma <- 2
mx <- 40                      # number of nodes in quadrature grid for X|Z
mc <- 40                      # number of nodes in quadrature grid for C|Z
my <- 5                       # number of nodes in quadrature grid for Y|X,Z
dat.list <- gen.data.beta(n = n, q = q, B = B, s2 = s2,
x.thetas = x.thetas, x.gamma = x.gamma, c.gamma)
datf <- dat.list$datf          # full data
dat0 <- dat.list$dat0          # oracle data
dat <- dat.list$dat            # observed data
datcc <- dat.list$datcc        # complete case data
zs <- sort(unique(dat$Z))      # unique z values
## estimated parameters for X|Z
x.fit <- dat %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
x.params.hat <- x.fit$estimate
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat["shape1"],
shape2 = x.params.hat["shape2"])
}
## estimated parameters for C|Z
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
## estimated density of C|Z
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
knitr::opts_chunk$set(echo = TRUE)
# load the package
library(sparcc)
# other necessary packages
library(dplyr)
# define parameters -------------------------------------------------------
set.seed(1)                   # random number seed for reproducibility
B <- c(1, 10, 2)              # outcome model parameters
s2 <- 1                       # Var(Y|X,Z)
x.thetas <- 0.5 * c(-1, 1)    # parameters governing X|Z and C|Z
x.gamma <- 1
c.gamma <- 2
mx <- 40                      # number of nodes in quadrature grid for X|Z
mc <- 40                      # number of nodes in quadrature grid for C|Z
my <- 5                       # number of nodes in quadrature grid for Y|X,Z
q
# compare estimates
round(rbind(c(B, log(s2)), B.or, B.cc, B.mle, B.sp), 2)
knitr::opts_chunk$set(echo = TRUE)
# load the package
library(sparcc)
# other necessary packages
library(dplyr)
# define parameters -------------------------------------------------------
set.seed(123)                 # random number seed for reproducibility
n <- 8000                     # sample size
q <- 0.8                      # censoring proportion
B <- c(1, 10, 2)              # outcome model parameters
s2 <- 1                       # Var(Y|X,Z)
x.thetas <- 0.5 * c(-1, 1)    # parameters governing X|Z and C|Z
x.gamma <- 1
c.gamma <- 2
mx <- 40                      # number of nodes in quadrature grid for X|Z
mc <- 40                      # number of nodes in quadrature grid for C|Z
my <- 5                       # number of nodes in quadrature grid for Y|X,Z
dat.list <- gen.data.beta(n = n, q = q, B = B, s2 = s2,
x.thetas = x.thetas, x.gamma = x.gamma, c.gamma)
datf <- dat.list$datf          # full data
dat0 <- dat.list$dat0          # oracle data
dat <- dat.list$dat            # observed data
datcc <- dat.list$datcc        # complete case data
zs <- sort(unique(dat$Z))      # unique z values
## estimated parameters for X|Z
x.fit <- dat %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
x.params.hat <- x.fit$estimate
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat["shape1"],
shape2 = x.params.hat["shape2"])
}
## estimated parameters for C|Z
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
## estimated density of C|Z
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
## X|Z quadrature nodes
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
## X|Z quadrature weights
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) /
sum(eta1(x.nds[,i], zs[i])))
## C|Z quadrature nodes
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mc),
FUN = function(z) seq(1E-6, 1-1E-6, length = mc))
## X|Z quadrature weights
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mc),
FUN = function(i) eta2(c.nds[,i], zs[i]) /
sum(eta2(c.nds[,i], zs[i])))
## Y|X,Z quadrature
gq <- statmod::gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
## complete case linear model to get starting value
naive.lm <- lm(Y ~ W + Z, data = datcc)
## complete case
B.cc <- get.root(dat = dat, score = get.Scc,
start = c(naive.lm$coef, log(var(naive.lm$resid))))
round(B.cc, 2)
## oracle
B.or <- get.root(dat = dat0, score = get.Scc, start = B.cc)
round(B.or, 2)
## MLE
mle.args <- list(x.nds = x.nds, x.wts = x.wts)
B.mle <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
round(B.mle, 2)
## semiparametric efficient estimator
sp.args <- list(x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts)
B.sp <- get.root(dat = dat, score = get.Seff, start = B.cc,
args = sp.args)
round(B.sp, 2)
V.cc <- var.est(dat = datcc, theta = B.cc, args = list(),
get.S = get.Scc, return.se = T)
V.cc
V.or <- var.est(dat = dat0, theta = B.or, args = list(),
get.S = get.Scc, return.se = T)
# complete case
SE.cc <- var.est(dat = datcc, theta = B.cc, args = list(),
get.S = get.Scc, return.se = T)
SE.or <- var.est(dat = dat0, theta = B.or, args = list(),
get.S = get.Scc, return.se = T)
SE.mle <- var.est(dat = dat, theta = B.mle,
args = mle.args, get.S = get.Sml, return.se = T)
SE.mle
# complete case
SE.cc <- var.est(dat = datcc, theta = B.cc, args = list(),
get.S = get.Scc, return.se = T)
## oracle
SE.or <- var.est(dat = dat0, theta = B.or, args = list(),
get.S = get.Scc, return.se = T)
## semiparametric efficient
SE.sp <- var.est(dat = dat, theta = B.sp.11,
args = sp.args, get.S = get.Seff, return.se = T)
## semiparametric efficient
SE.sp <- var.est(dat = dat, theta = B.sp,
args = sp.args, get.S = get.Seff, return.se = T)
round(rbind(SE.or, SE.cc, SE.sp), 2)
round(rbind(SE.or, SE.cc, SE.sp), 3)
