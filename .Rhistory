}
eta2(c = head(dat$W, 5), z = head(dat$Z, 5))
# grid to plot X density
x.grid <- seq(0, 1, length = 100)
c.dens.hat <- lapply(
as.list(zs),
function(z) survPresmooth::presmooth(
times = dat$W[dat$Z == z],
status = 1 - dat$Delta[dat$Z == z],
estimand = "f",
x.est = seq(0, 1, length = 10^3),
fixed.bw = c.bw[[z + 1]],
#bw.selec = "plug-in",
))
eta2 <- function(c, z) {
eta <- numeric(length(c))
for (zz in unique(z)) {
eta[z == zz] <- approx(
x = c.dens.hat[[zz + 1]]$x.est,
y = c.dens.hat[[zz + 1]]$estimate,
xout = c[z == zz],
rule = 2
)$y
}
return(eta)
}
# grid to plot X density
x.grid <- seq(0, 1, length = 100)
# plot data
datf %>%
mutate(e1 = eta1(x = X, z = Z),
e2 = eta2(c = C, z = Z)) %>%
ggplot() +
geom_histogram(aes(x = X,
y = after_stat(density)),
fill = "blue", alpha = 0.5, bins = n/50) +
geom_histogram(aes(x = C,
y = after_stat(density)),
fill = "red", alpha = 0.5, bins = n/50) +
geom_line(aes(x = X,
y = e1),
color = "blue", linewidth = 1) +
geom_line(aes(x = C,
y = e2),
color = "red", linewidth = 1) +
facet_wrap(~ Z,
scales = "free", labeller = label_both) +
labs(x = "X (blue) or C (red)",
y = "Density") +
ggtitle("Estimated vs Observed Distributions of X|Z and C|Z")
# X|Z quadrature
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
# C|Z quadrature
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mc),
FUN = function(z) seq(1E-6, 1-1E-6, length = mc))
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mc),
FUN = function(i) eta2(c.nds[,i], zs[i]) / sum(eta2(c.nds[,i], zs[i])))
# Y quadrature
gq <- gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
# oracle
S0 <- get.Scc(dat = dat0, B = B, ls2 = ls2,
args = list(mu = mu, d.mu = d.mu, SF = SF),
return.sums = F)
assess.ee(S0)
# complete case
Scc <- get.Scc(dat = dat, B = B, ls2 = ls2,
args = list(mu = mu, d.mu = d.mu, SF = SF),
return.sums = F)
assess.ee(Scc)
# MLE
Sml <- get.Sml(dat = dat, B = B, ls2 = ls2,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts),
return.sums = F)
assess.ee(Sml)
# semiparametric efficient score
Seff <- get.Seff(dat = dat, B = B, ls2 = ls2,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy, eta1 = eta1,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts),
return.sums = F)
assess.ee(Seff)
# complete case lm to get starting value
naive.lm <- lm(Y ~ W + Z, data = datcc)
# complete case
Bcc <- get.root(dat = dat, score = get.Scc,
start = c(naive.lm$coef, log(var(naive.lm$resid))))
Bcc
# oracle
B0 <- get.root(dat = dat0, score = get.Scc,
start = Bcc)
B0
# MLE
Bmle <- get.root(dat = dat, score = get.Sml, start = Bcc,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts))
Bmle
# semiparametric efficient score
Beff <- get.root(dat = dat, score = get.Seff, start = Bcc,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
eta1 = eta1,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts))
Beff
# compare estimates
rbind(c(B, log(s2)), B0, Bcc, Bmle, Beff)
rm(list = ls())
#setwd(dirname(getwd()))
library(statmod)
library(ggplot2)
library(tidyverse)
library(pbapply)
library(devtools)
load_all()
n <- 8000                  # sample size
q <- 0.8                   # censoring proportion
B <- c(1, .2)              # outcome model parameters
s2 <- 1.1                  # Var(Y|X,Z)
x.mean <- 0.5
x.shape <- 1.2
c.shape <- 2
x.rate <- x.shape / x.mean # rate parameter for gamma distribution of X
c.rate <- get.c.rate(      # rate parameter for gamma distribution of C
q = q,
x.rate = x.rate,
x.shape = x.shape,
c.shape = c.shape)
specify.x.gamma <- T
specify.c.gamma <- T
# mean function mu(X, B) = E(Y | X)
mu <- function(x, B) {
B[1] + B[2]*x
}
# gradient of mu w.r.t. B
d.mu <- function(x, B) {
cbind(1, x)
}
## generate data
dat.list <- gen.data(n = n, q = q, B = B, s2 = s2,
x.rate = x.rate, x.shape = x.shape,
c.rate = c.rate, c.shape = c.shape)
datf <- dat.list$datf          # full data
## generate data
dat.list <- gen.data.gamma(n = n, q = q, B = B, s2 = s2,
x.rate = x.rate, x.shape = x.shape,
c.rate = c.rate, c.shape = c.shape)
rm(list = ls())
#setwd(dirname(getwd()))
library(statmod)
library(devtools)
library(fitdistrplus)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(pbapply)
load_all()
set.seed(2)
n <- 8000             # sample size
q <- 0.5              # censoring proportion
B <- c(1, 10, 2)      # beta
s2 <- 4               # variance of Y|X,Z
x.thetas <- c(0.5, -0.5)   # theta parameters for X|Z
x.gamma <- 1          # gamma parameter for X|Z
c.gamma <- 4          # gamma parameter for C|Z
x.correct <- T       # indicator for estimating X as gamma
c.correct <- T       # indicator for estimating C as gamma
# mean function mu(X, Z, B) = E(Y | X, Z)
mu <- function(x, z, B) {
B[1] + B[2]*x + B[3]*z
}
# gradient of mu w.r.t. B
d.mu <- function(x, z, B) {
cbind(1, x, z)
}
# Y|X, Z density
fy <- function(y, x, z, B, s2) dnorm(x = y, mean = mu(x, z, B), sd = sqrt(s2))
dat.list <- gen.data.beta(
n = n, q = q, B = B, s2 = s2,
x.thetas = x.thetas, x.gamma = x.gamma, c.gamma = c.gamma)
datf <- dat.list$datf          # full data
dat0 <- dat.list$dat0          # oracle data
dat <- dat.list$dat            # observed data
datcc <- dat.list$datcc        # complete case data
zs <- sort(unique(dat$Z))      # unique z values
# estimate distribution of X|Z
if (x.correct == T) {
# estimate beta parameters at each level of Z
x.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat[z + 1, "shape1"],
shape2 = x.params.hat[z + 1, "shape2"])
}
} else {
# misspecify: estimate marginal beta distribution
est <- dat %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
x.params.hat <- est$estimate
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat["shape1"],
shape2 = x.params.hat["shape2"])
}
}
# estimate distribution of C|Z
if (c.correct) {
# estimate beta parameters at each level of Z
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
# define estimated C|Z density
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
} else {
# misspecify: estimate marginal beta distribution
est <- dat %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
c.params.hat <- est$estimate
# define estimated X|Z density
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat["shape1"],
shape2 = c.params.hat["shape2"])
}
}
# grid of possible values for mx and mc
mx.grid <- seq(15, 55, by = 5)
mc.grid <- seq(15, 55, by = 5)
my.grid <- seq(2, 6, by = 2)
search.in <- expand.grid(mx = mx.grid,
mc = mc.grid,
my = my.grid)
# store Seff and computation time for each mx, mc, my (takes ~ 4 min to run)
search.out <- pbvapply(
X = 1:nrow(search.in),
FUN.VALUE = numeric(8),
FUN = function(ii) {
# X|Z quadrature
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(search.in$mx[ii]),
FUN = function(z) seq(1E-6, 1-1E-6, length = search.in$mx[ii]))
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(search.in$mx[ii]),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
# C|Z quadrature
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(search.in$mc[ii]),
FUN = function(z) seq(1E-6, 1-1E-6, length = search.in$mc[ii]))
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(search.in$mc[ii]),
FUN = function(i) eta2(c.nds[,i], zs[i]) / sum(eta2(c.nds[,i], zs[i])))
# Y quadrature
gq <- gauss.quad(n = search.in$my[ii], kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
# evaluate efficient score
st <- Sys.time()
Seff <- get.Seff(dat = dat, B = B, s2 = s2,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy, eta1 = eta1,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts),
return.sums = T)
et <- Sys.time()
return(c(mx = search.in$mx[ii],
mc = search.in$mc[ii],
my = search.in$my[ii],
Seff = Seff,
Time = et - st))
}) %>%
t() %>%
as.data.frame()
# store Seff and computation time for each mx, mc, my (takes ~ 4 min to run)
if (run.search) {
search.out <- pbvapply(
X = 1:nrow(search.in),
FUN.VALUE = numeric(8),
FUN = function(ii) {
# X|Z quadrature
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(search.in$mx[ii]),
FUN = function(z) seq(1E-6, 1-1E-6, length = search.in$mx[ii]))
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(search.in$mx[ii]),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
# C|Z quadrature
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(search.in$mc[ii]),
FUN = function(z) seq(1E-6, 1-1E-6, length = search.in$mc[ii]))
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(search.in$mc[ii]),
FUN = function(i) eta2(c.nds[,i], zs[i]) / sum(eta2(c.nds[,i], zs[i])))
# Y quadrature
gq <- gauss.quad(n = search.in$my[ii], kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
# evaluate efficient score
st <- Sys.time()
Seff <- get.Seff(dat = dat, B = B, ls2 = log(s2),
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy, eta1 = eta1,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts),
return.sums = T)
et <- Sys.time()
return(c(mx = search.in$mx[ii],
mc = search.in$mc[ii],
my = search.in$my[ii],
Seff = Seff,
Time = et - st))
}) %>%
t() %>%
as.data.frame()
write.csv(search.out, "dev_data/m_tuning_beta.csv", row.names = F)
}
run.search <- T
# grid of possible values for mx and mc
mx.grid <- seq(15, 55, by = 5)
mc.grid <- seq(15, 55, by = 5)
my.grid <- seq(2, 6, by = 2)
search.in <- expand.grid(mx = mx.grid,
mc = mc.grid,
my = my.grid)
# store Seff and computation time for each mx, mc, my (takes ~ 4 min to run)
if (run.search) {
search.out <- pbvapply(
X = 1:nrow(search.in),
FUN.VALUE = numeric(8),
FUN = function(ii) {
# X|Z quadrature
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(search.in$mx[ii]),
FUN = function(z) seq(1E-6, 1-1E-6, length = search.in$mx[ii]))
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(search.in$mx[ii]),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
# C|Z quadrature
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(search.in$mc[ii]),
FUN = function(z) seq(1E-6, 1-1E-6, length = search.in$mc[ii]))
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(search.in$mc[ii]),
FUN = function(i) eta2(c.nds[,i], zs[i]) / sum(eta2(c.nds[,i], zs[i])))
# Y quadrature
gq <- gauss.quad(n = search.in$my[ii], kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
# evaluate efficient score
st <- Sys.time()
Seff <- get.Seff(dat = dat, B = B, ls2 = log(s2),
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy, eta1 = eta1,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts),
return.sums = T)
et <- Sys.time()
return(c(mx = search.in$mx[ii],
mc = search.in$mc[ii],
my = search.in$my[ii],
Seff = Seff,
Time = et - st))
}) %>%
t() %>%
as.data.frame()
write.csv(search.out, "dev_data/m_tuning_beta.csv", row.names = F)
}
# load results
search.out <- read.csv("dev_data/m_tuning_beta.csv")
search.out.long <- search.out %>%
pivot_longer(cols = c(Seff1, Seff2, Time)) %>%
mutate(mc = factor(mc),
mx = factor(mx),
my = factor(my))
# load results
search.out <- read.csv("dev_data/m_tuning_beta.csv")
getwd()
# load results
search.out <- read.csv("development/dev_data/m_tuning_beta.csv")
search.out.long <- search.out %>%
pivot_longer(cols = c(Seff1, Seff2, Time)) %>%
mutate(mc = factor(mc),
mx = factor(mx),
my = factor(my))
mc.labs <- paste0("mc = ", mc.grid); names(mc.labs) <- mc.grid
my.labs <- paste0("my = ", my.grid); names(my.labs) <- my.grid
# facet by Y
ggplot(data = search.out.long,
aes(x = mx,
y = value,
color = mc,
group = mc)) +
geom_line() +
facet_grid(name ~ my,
scales = "free",
labeller = labeller(my = my.labs)) +
labs(y = "") +
ggtitle("Score Values and Computation Time by Node Counts mx and mc")
# load results
search.out <- read.csv("development/dev_data/m_tuning_beta.csv")
search.out.long <- search.out %>%
pivot_longer(cols = c(Seff1, Seff2, Time)) %>%
mutate(mc = factor(mc),
mx = factor(mx),
my = factor(my))
mc.labs <- paste0("mc = ", mc.grid); names(mc.labs) <- mc.grid
my.labs <- paste0("my = ", my.grid); names(my.labs) <- my.grid
# facet by Y
ggplot(data = search.out.long,
aes(x = mx,
y = value,
color = mc,
group = mc)) +
geom_line() +
facet_grid(name ~ my,
scales = "free",
labeller = labeller(my = my.labs)) +
labs(y = "") +
ggtitle("Score Values and Computation Time by Node Counts mx and mc")
# facet by C
ggplot(data = search.out.long,
aes(x = mx,
y = value,
color = my,
group = my)) +
geom_line() +
facet_grid(name ~ mc,
scales = "free",
labeller = labeller(mc = mc.labs)) +
labs(y = "") +
ggtitle("Score Values and Computation Time by Node Counts mx and mc")
# facet by Y
ggplot(data = search.out.long,
aes(x = mx,
y = value,
color = mc,
group = mc)) +
geom_line() +
facet_grid(name ~ my,
scales = "free",
labeller = labeller(my = my.labs)) +
labs(y = "") +
ggtitle("Score Values and Computation Time by Node Counts mx and mc")
# facet by C
ggplot(data = search.out.long,
aes(x = mx,
y = value,
color = my,
group = my)) +
geom_line() +
facet_grid(name ~ mc,
scales = "free",
labeller = labeller(mc = mc.labs)) +
labs(y = "") +
ggtitle("Score Values and Computation Time by Node Counts mx and mc")
