dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
## estimated density of C|Z
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
## X|Z quadrature nodes
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
## X|Z quadrature weights
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) /
sum(eta1(x.nds[,i], zs[i])))
## C|Z quadrature nodes
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mc),
FUN = function(z) seq(1E-6, 1-1E-6, length = mc))
## X|Z quadrature weights
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mc),
FUN = function(i) eta2(c.nds[,i], zs[i]) /
sum(eta2(c.nds[,i], zs[i])))
## Y|X,Z quadrature
gq <- statmod::gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
## complete case linear model to get starting value
naive.lm <- lm(Y ~ W + Z, data = datcc)
## complete case
B.cc <- get.root(dat = dat, score = get.Scc,
start = c(naive.lm$coef, log(var(naive.lm$resid))))
round(B.cc, 2)
## oracle
B.or <- get.root(dat = dat0, score = get.Scc, start = B.cc)
round(B.or, 2)
## MLE
mle.args <- list(x.nds = x.nds, x.wts = x.wts)
B.mle <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
round(B.mle, 2)
## semiparametric efficient estimator
sp.args <- list(x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts)
B.sp <- get.root(dat = dat, score = get.Seff, start = B.cc,
args = sp.args)
round(B.sp, 2)
# compare estimates
round(rbind(c(B, log(s2)), B.or, B.cc, B.mle, B.sp), 2)
# complete case
SE.cc <- var.est.sand(dat = datcc, theta = B.cc, args = list(),
n = sum(dat$Delta),
get.S = get.Scc, return.se = T)
knitr::opts_chunk$set(echo = TRUE)
# install the package
devtools::install_github(repo = "brian-d-richardson/sparcc",
ref = "main")
knitr::opts_chunk$set(echo = TRUE)
# load the package
library(sparcc)
# other necessary packages
library(dplyr)
# define parameters -------------------------------------------------------
set.seed(123)                 # random number seed for reproducibility
n <- 8000                     # sample size
q <- 0.8                      # censoring proportion
B <- c(1, 10, 2)              # outcome model parameters
s2 <- 1                       # Var(Y|X,Z)
x.thetas <- 0.5 * c(-1, 1)    # parameters governing X|Z and C|Z
x.gamma <- 1
c.gamma <- 2
mx <- 40                      # number of nodes in quadrature grid for X|Z
mc <- 40                      # number of nodes in quadrature grid for C|Z
my <- 5                       # number of nodes in quadrature grid for Y|X,Z
dat.list <- gen.data.beta(n = n, q = q, B = B, s2 = s2,
x.thetas = x.thetas, x.gamma = x.gamma, c.gamma)
datf <- dat.list$datf          # full data
dat0 <- dat.list$dat0          # oracle data
dat <- dat.list$dat            # observed data
datcc <- dat.list$datcc        # complete case data
zs <- sort(unique(dat$Z))      # unique z values
## estimated parameters for X|Z
x.fit <- dat %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
x.params.hat <- x.fit$estimate
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat["shape1"],
shape2 = x.params.hat["shape2"])
}
## estimated parameters for C|Z
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
## estimated density of C|Z
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
## X|Z quadrature nodes
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
## X|Z quadrature weights
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) /
sum(eta1(x.nds[,i], zs[i])))
## C|Z quadrature nodes
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mc),
FUN = function(z) seq(1E-6, 1-1E-6, length = mc))
## X|Z quadrature weights
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mc),
FUN = function(i) eta2(c.nds[,i], zs[i]) /
sum(eta2(c.nds[,i], zs[i])))
## Y|X,Z quadrature
gq <- statmod::gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
## complete case linear model to get starting value
naive.lm <- lm(Y ~ W + Z, data = datcc)
## complete case
B.cc <- get.root(dat = dat, score = get.Scc,
start = c(naive.lm$coef, log(var(naive.lm$resid))))
round(B.cc, 2)
## oracle
B.or <- get.root(dat = dat0, score = get.Scc, start = B.cc)
round(B.or, 2)
## MLE
mle.args <- list(x.nds = x.nds, x.wts = x.wts)
B.mle <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
round(B.mle, 2)
## semiparametric efficient estimator
sp.args <- list(x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts)
B.sp <- get.root(dat = dat, score = get.Seff, start = B.cc,
args = sp.args)
round(B.sp, 2)
# compare estimates
round(rbind(c(B, log(s2)), B.or, B.cc, B.mle, B.sp), 2)
# complete case
SE.cc <- var.est.sand(dat = datcc, theta = B.cc, args = list(),
n = sum(dat$Delta),
get.S = get.Scc, return.se = T)
## oracle
SE.or <- var.est.sand(dat = dat0, theta = B.or, args = list(),
get.S = get.Scc, return.se = T)
## MLE
SE.ml <- var.est.sand(
dat = dat,
get.S = function(dat, theta, args, return.sums = F) {
alpha <- tail(theta, -4)
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = alpha[1],
shape2 = alpha[2])
}
# create quadrature nodes
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
args <- list(x.nds = x.nds, x.wts = x.wts)
# stack estimating equations
S <- cbind(get.Sml(dat = dat, theta = head(theta, 4),
args = args, return.sums = F),
d.log.fx(dat = dat, theta = alpha,
args = args, return.sums = F))
if (return.sums) {
return(colSums(S))
} else {
return(S)
}
},
theta = c(B.ml.0, x.params.hat.wrong),
args = list(),
return.se = T)
## MLE
SE.ml <- var.est.sand(
dat = dat,
get.S = function(dat, theta, args, return.sums = F) {
alpha <- tail(theta, -4)
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = alpha[1],
shape2 = alpha[2])
}
# create quadrature nodes
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
args <- list(x.nds = x.nds, x.wts = x.wts)
# stack estimating equations
S <- cbind(get.Sml(dat = dat, theta = head(theta, 4),
args = args, return.sums = F),
d.log.fx(dat = dat, theta = alpha,
args = args, return.sums = F))
if (return.sums) {
return(colSums(S))
} else {
return(S)
}
},
theta = c(B.ml, x.params.hat.wrong),
args = list(),
return.se = T)
B.mle
## MLE
SE.ml <- var.est.sand(
dat = dat,
get.S = function(dat, theta, args, return.sums = F) {
alpha <- tail(theta, -4)
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = alpha[1],
shape2 = alpha[2])
}
# create quadrature nodes
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
args <- list(x.nds = x.nds, x.wts = x.wts)
# stack estimating equations
S <- cbind(get.Sml(dat = dat, theta = head(theta, 4),
args = args, return.sums = F),
d.log.fx(dat = dat, theta = alpha,
args = args, return.sums = F))
if (return.sums) {
return(colSums(S))
} else {
return(S)
}
},
theta = c(B.mle, x.params.hat),
args = list(),
return.se = T)
library(mismex)
library(sparcc)
?d.log.fx
?d.log.fxz
?sparcc
??sparcc
getwd()
document()
library(devtools)
document()
knitr::opts_chunk$set(echo = TRUE)
# install the package
devtools::install_github(repo = "brian-d-richardson/sparcc",
ref = "main")
knitr::opts_chunk$set(echo = TRUE)
# install the package
devtools::install_github(repo = "brian-d-richardson/sparcc",
ref = "main")
knitr::opts_chunk$set(echo = TRUE)
# load the package
library(sparcc)
# other necessary packages
library(dplyr)
# define parameters -------------------------------------------------------
set.seed(123)                 # random number seed for reproducibility
n <- 8000                     # sample size
q <- 0.8                      # censoring proportion
B <- c(1, 10, 2)              # outcome model parameters
s2 <- 1                       # Var(Y|X,Z)
x.thetas <- 0.5 * c(-1, 1)    # parameters governing X|Z and C|Z
x.gamma <- 1
c.gamma <- 2
mx <- 40                      # number of nodes in quadrature grid for X|Z
mc <- 40                      # number of nodes in quadrature grid for C|Z
my <- 5                       # number of nodes in quadrature grid for Y|X,Z
dat.list <- gen.data.beta(n = n, q = q, B = B, s2 = s2,
x.thetas = x.thetas, x.gamma = x.gamma, c.gamma)
datf <- dat.list$datf          # full data
dat0 <- dat.list$dat0          # oracle data
dat <- dat.list$dat            # observed data
datcc <- dat.list$datcc        # complete case data
zs <- sort(unique(dat$Z))      # unique z values
## estimated parameters for X|Z
x.fit <- dat %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
x.params.hat <- x.fit$estimate
## estimated density of X|Z
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat["shape1"],
shape2 = x.params.hat["shape2"])
}
## estimated parameters for C|Z
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 0, W, NA)) %>%
dplyr::select(left, right) %>%
fitdistrplus::fitdistcens(distr = "beta")
return(est$estimate)
}))
## estimated density of C|Z
eta2 <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
## X|Z quadrature nodes
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
## X|Z quadrature weights
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) /
sum(eta1(x.nds[,i], zs[i])))
## C|Z quadrature nodes
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mc),
FUN = function(z) seq(1E-6, 1-1E-6, length = mc))
## X|Z quadrature weights
c.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mc),
FUN = function(i) eta2(c.nds[,i], zs[i]) /
sum(eta2(c.nds[,i], zs[i])))
## Y|X,Z quadrature
gq <- statmod::gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
## complete case linear model to get starting value
naive.lm <- lm(Y ~ W + Z, data = datcc)
## complete case
B.cc <- get.root(dat = dat, score = get.Scc,
start = c(naive.lm$coef, log(var(naive.lm$resid))))
round(B.cc, 2)
## oracle
B.or <- get.root(dat = dat0, score = get.Scc, start = B.cc)
round(B.or, 2)
## MLE
mle.args <- list(x.nds = x.nds, x.wts = x.wts)
B.mle <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
round(B.mle, 2)
## semiparametric efficient estimator
sp.args <- list(x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts)
B.sp <- get.root(dat = dat, score = get.Seff, start = B.cc,
args = sp.args)
round(B.sp, 2)
# compare estimates
round(rbind(c(B, log(s2)), B.or, B.cc, B.mle, B.sp), 2)
# complete case
SE.cc <- var.est.sand(dat = datcc, theta = B.cc, args = list(),
n = sum(dat$Delta),
get.S = get.Scc, return.se = T)
## oracle
SE.or <- var.est.sand(dat = dat0, theta = B.or, args = list(),
get.S = get.Scc, return.se = T)
## MLE
SE.ml <- var.est.sand(
dat = dat,
get.S = function(dat, theta, args, return.sums = F) {
alpha <- tail(theta, -4)
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = alpha[1],
shape2 = alpha[2])
}
# create quadrature nodes
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
args <- list(x.nds = x.nds, x.wts = x.wts)
# stack estimating equations
S <- cbind(get.Sml(dat = dat, theta = head(theta, 4),
args = args, return.sums = F),
d.log.fx(dat = dat, theta = alpha,
args = args, return.sums = F))
if (return.sums) {
return(colSums(S))
} else {
return(S)
}
},
theta = c(B.mle, x.params.hat),
args = list(),
return.se = T)
SE.ml
## semiparametric efficient
SE.sp <- var.est.sand(dat = dat, theta = B.sp.01,
args = sp.args),
## semiparametric efficient
SE.sp <- var.est.sand(dat = dat, theta = B.sp.01,
args = sp.args,
get.S = get.Seff, return.se = T)
## semiparametric efficient
SE.sp <- var.est.sand(dat = dat, theta = B.sp,
args = sp.args,
get.S = get.Seff, return.se = T)
round(rbind(SE.or, SE.cc, SE.mle, SE.sp), 3)
## MLE
SE.mle <- var.est.sand(
dat = dat,
get.S = function(dat, theta, args, return.sums = F) {
alpha <- tail(theta, -4)
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = alpha[1],
shape2 = alpha[2])
}
# create quadrature nodes
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
args <- list(x.nds = x.nds, x.wts = x.wts)
# stack estimating equations
S <- cbind(get.Sml(dat = dat, theta = head(theta, 4),
args = args, return.sums = F),
d.log.fx(dat = dat, theta = alpha,
args = args, return.sums = F))
if (return.sums) {
return(colSums(S))
} else {
return(S)
}
},
theta = c(B.mle, x.params.hat),
args = list(),
return.se = T)
round(rbind(SE.or, SE.cc, SE.mle, SE.sp), 3)
round(rbind(SE.or, SE.cc, SE.mle[1:4], SE.sp), 3)
## MLE
SE.mle <- var.est.sand(
dat = dat,
get.S = function(dat, theta, args, return.sums = F) {
alpha <- tail(theta, -4)
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = alpha[1],
shape2 = alpha[2])
}
# create quadrature nodes
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
args <- list(x.nds = x.nds, x.wts = x.wts)
# stack estimating equations
S <- cbind(get.Sml(dat = dat, theta = head(theta, 4),
args = args, return.sums = F),
d.log.fx(dat = dat, theta = alpha,
args = args, return.sums = F))
if (return.sums) {
return(colSums(S))
} else {
return(S)
}
},
theta = c(B.mle, x.params.hat),
args = list(),
return.se = T)[1:4]
round(rbind(SE.or, SE.cc, SE.mle, SE.sp), 3)
