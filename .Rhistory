rm(list = ls())
setwd(dirname(getwd()))
source("R/int_eq.R"); source("R/est_funs.R");
source("R/misc_helpers.R"); source("R/sims.R");
source("R/data_gen.R")
# baseline seed (specific to cluster)
args <- commandArgs(TRUE)
args = 1
base.seed <- 10^6 * as.integer(args)
source("R/sims.R");
n.sim <- 1
# output size
len.out <- 17
# varied parameters
n <- 10000
q <- c(0.4, 0.8)
x.shape <- c(1, 4)
c.shape <- c(1, 4)
# run simulations ---------------------------------------------------------
# create simulation input
sim.in <- expand.grid(n = n,
q = q,
x.shape = x.shape,
c.shape = c.shape,
sim.id = 1:n.sim + base.seed)
# run simulations
sim.out <- pbapply::pbvapply(
X = 1:nrow(sim.in),
FUN = function(ii) {
sim1(n = sim.in$n[ii],
q = sim.in$q[ii],
x.shape = sim.in$x.shape[ii],
c.shape = sim.in$c.shape[ii],
mx = 100,
mc = 15,
my = 2,
seed = sim.in$sim.id[ii])
},
FUN.VALUE = numeric(len.out)) |>
t()
len.out <- 20
# varied parameters
n <- 10000
q <- c(0.4, 0.8)
x.shape <- c(1, 4)
c.shape <- c(1, 4)
# run simulations ---------------------------------------------------------
# create simulation input
sim.in <- expand.grid(n = n,
q = q,
x.shape = x.shape,
c.shape = c.shape,
sim.id = 1:n.sim + base.seed)
# run simulations
sim.out <- pbapply::pbvapply(
X = 1:nrow(sim.in),
FUN = function(ii) {
sim1(n = sim.in$n[ii],
q = sim.in$q[ii],
x.shape = sim.in$x.shape[ii],
c.shape = sim.in$c.shape[ii],
mx = 100,
mc = 15,
my = 2,
seed = sim.in$sim.id[ii])
},
FUN.VALUE = numeric(len.out)) |>
t()
View(sim.out)
n = 10000; q = 0.8; x.shape = 1; c.shape = 1; mx = 50; mc = 15; my = 2; seed = 1
set.seed(seed)
## define parameters
B <- c(1, 2)               # outcome model parameters
s2 <- 0.81                 # Var(Y|X,Z)
x.mean <- 0.25
x.rate <- x.shape / x.mean # rate parameter for gamma distribution of X
c.rate <- get.c.rate(      # rate parameter for gamma distribution of C
q = q,
x.rate = x.rate,
x.shape = x.shape,
c.shape = c.shape)
## generate data
dat.list <- gen.data(n = n, q = q, B = B,
x.rate = x.rate, x.shape = x.shape,
c.rate = c.rate, c.shape = c.shape)
datf <- dat.list$datf          # full data
dat0 <- dat.list$dat0          # oracle data
dat <- dat.list$dat            # observed data
datcc <- dat.list$datcc        # complete case data
## define densities
# X density
eta1 <- function(x) dexp(x, rate = x.rate / x.shape)
# C density
eta2 <- function(c) dexp(c, rate = c.rate / c.shape)
# mean function mu(X, B) = E(Y | X)
mu <- function(x, B) {
B[1] + B[2]*x
}
# gradient of mu w.r.t. B
d.mu <- function(x, B) {
cbind(1, x)
}
# Y density
fy <- function(y, x, B, s2) dnorm(x = y, mean = mu(x, B), sd = sqrt(s2))
# full data score vector
SF <- function(y, x, B, s2) {
cbind((y - mu(x, B)) * d.mu(x, B),
(y - mu(x, B)) ^ 2 - s2)
}
## create quadrature rules
# X quadrature
x.nds <- seq(10^-6, max(datf$X), length = mx)
x.wts <- eta1(x.nds) / sum(eta1(x.nds))
# C quadrature
c.nds <- seq(10^-6, max(datf$C), length = mc)
c.wts <- eta2(c.nds) / sum(eta2(c.nds))
# Y quadrature
gq <- statmod::gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
## estimate parameters
# oracle
B0 <- get.root(dat = dat0, score = get.Scc, start = c(0, 0, 0))
# complete case
Bcc <- get.root(dat = dat, score = get.Scc, start = c(0, 0, 0))
B0
Bcc
# MLE
Bmle <- get.root(dat = dat, score = get.Sml, start = Bcc,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts))
# semiparametric efficient score
Beff <- get.root(dat = dat, score = get.Seff, start = Bcc,
args = list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts,
c.nds = c.nds, c.wts = c.wts,
y.nds = y.nds, y.wts = y.wts))
exp(B0[3])
log(s2)
source("R/int_eq.R"); source("R/est_funs.R");
source("R/misc_helpers.R"); source("R/sims.R");
source("R/data_gen.R")
args = 1
base.seed <- 10^6 * as.integer(args)
# number of sims per cluster
n.sim <- 1
# output size
len.out <- 20
# varied parameters
n <- 10000
q <- c(0.4, 0.8)
x.shape <- c(1, 4)
c.shape <- c(1, 4)
# run simulations ---------------------------------------------------------
# create simulation input
sim.in <- expand.grid(n = n,
q = q,
x.shape = x.shape,
c.shape = c.shape,
sim.id = 1:n.sim + base.seed)
# run simulations
sim.out <- pbapply::pbvapply(
X = 1:nrow(sim.in),
FUN = function(ii) {
sim1(n = sim.in$n[ii],
q = sim.in$q[ii],
x.shape = sim.in$x.shape[ii],
c.shape = sim.in$c.shape[ii],
mx = 100,
mc = 15,
my = 2,
seed = sim.in$sim.id[ii])
},
FUN.VALUE = numeric(len.out)) |>
t()
log(s2)
source("R/int_eq.R"); source("R/est_funs.R");
source("R/misc_helpers.R"); source("R/sims.R");
source("R/data_gen.R")
# simulation parameters ---------------------------------------------------
# baseline seed (specific to cluster)
args <- commandArgs(TRUE)
base.seed <- 10^6 * as.integer(args)
# number of sims per cluster
n.sim <- 1
# output size
len.out <- 20
# varied parameters
n <- 10000
q <- c(0.4, 0.8)
x.shape <- c(1, 4)
c.shape <- c(1, 4)
# run simulations ---------------------------------------------------------
# create simulation input
sim.in <- expand.grid(n = n,
q = q,
x.shape = x.shape,
c.shape = c.shape,
sim.id = 1:n.sim + base.seed)
# run simulations
sim.out <- pbapply::pbvapply(
X = 1:nrow(sim.in),
FUN = function(ii) {
sim1(n = sim.in$n[ii],
q = sim.in$q[ii],
x.shape = sim.in$x.shape[ii],
c.shape = sim.in$c.shape[ii],
mx = 100,
mc = 15,
my = 2,
seed = sim.in$sim.id[ii])
},
FUN.VALUE = numeric(len.out)) |>
t()
args = 1
base.seed <- 10^6 * as.integer(args)
# number of sims per cluster
n.sim <- 1
# output size
len.out <- 20
# varied parameters
n <- 10000
q <- c(0.4, 0.8)
x.shape <- c(1, 4)
c.shape <- c(1, 4)
# run simulations ---------------------------------------------------------
# create simulation input
sim.in <- expand.grid(n = n,
q = q,
x.shape = x.shape,
c.shape = c.shape,
sim.id = 1:n.sim + base.seed)
# run simulations
sim.out <- pbapply::pbvapply(
X = 1:nrow(sim.in),
FUN = function(ii) {
sim1(n = sim.in$n[ii],
q = sim.in$q[ii],
x.shape = sim.in$x.shape[ii],
c.shape = sim.in$c.shape[ii],
mx = 100,
mc = 15,
my = 2,
seed = sim.in$sim.id[ii])
},
FUN.VALUE = numeric(len.out)) |>
t()
