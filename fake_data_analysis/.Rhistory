mle.args <- list(x.nds = x.nds, x.wts = x.wts.param,
xz.interaction = T)
tic("MLE estimate")
B.ml <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
toc()
tic("MLE variance")
V.ml <- var.est.sand(
dat = dat,
get.S = function(dat, theta, args, return.sums = F) {
# extract X|Z parameters
alpha <- matrix(tail(theta, -5), ncol = length(zs))
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = alpha[z + 1],
shape2 = alpha[z + 3])
}
# create quadrature nodes
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
args <- list(x.nds = x.nds, x.wts = x.wts, xz.interaction = T)
# stack estimating equations
S <- cbind(get.Sml(dat = dat, theta = head(theta, 5),
args = args, return.sums = F),
d.log.fxz(dat = dat, theta = alpha,
args = args, return.sums = F))
if (return.sums) {
return(colSums(S))
} else {
return(S)
}
},
theta = c(B.ml, x.params.hat),
args = list(),
return.se = F)
toc()
saveRDS(list(B = B.ml, V = V.ml),
file = "derived-data/SDMT-results/ml_res")
cbind(B.ml, sqrt(diag(V.ml)[1:5]))
## semiparametric (X|Z, C|Z nonparametric)
sp.nonpar.args <- list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, c.nds = c.nds,
y.nds = y.nds, y.wts = y.wts,
x.wts = x.wts.nonpar,
c.wts = c.wts.nonpar,
eta1 = eta1.nonpar,
xz.interaction = T)
tic("SP (nonpar) estimate")
B.sp.nonpar <- get.root(dat = dat, score = get.Seff,
start = B.cc,
args = sp.nonpar.args)
toc()
tic("SP (nonpar) variance")
V.sp.nonpar <- var.est.sand(dat = dat, theta = B.sp.nonpar,
args = sp.nonpar.args,
get.S = get.Seff, return.se = F)
toc()
saveRDS(list(B = B.sp.nonpar, V = V.sp.nonpar),
file = "derived-data/SDMT-results/sp_nonpar_res")
cbind(B.sp.nonpar, sqrt(diag(V.sp.nonpar)))
## semiparametric (X|Z, C|Z parametric)
sp.param.args <- list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, c.nds = c.nds,
y.nds = y.nds, y.wts = y.wts,
x.wts = x.wts.param,
c.wts = c.wts.param,
eta1 = eta1.param,
xz.interaction = T)
tic("SP (param) estimate")
B.sp.param <- get.root(dat = dat, score = get.Seff,
start = B.sp.nonpar,
args = sp.param.args)
toc()
tic("SP (param) variance")
V.sp.param <- var.est.sand(dat = dat, theta = B.sp.param,
args = sp.param.args,
get.S = get.Seff, return.se = F)
toc()
saveRDS(list(B = B.sp.param, V = V.sp.param),
file = "derived-data/SDMT-results/sp_param_res")
cbind(B.sp.param, sqrt(diag(V.sp.param)))
## results
res <- data.frame(
est = c(B.cc, B.ml, B.sp.param, B.sp.nonpar),
ste = c(sqrt(diag(V.cc)), sqrt(diag(V.ml)[1:5]),
sqrt(diag(V.sp.param)), sqrt(diag(V.sp.nonpar))),
param = rep(1:5, times = 4),
method = rep(c("CC", "MLE", "Semipar. (Param.)", "Semipar. (Nonpar.)"),
each = 5)) %>%
mutate(ci.lower = est - qnorm(0.975) * ste,
ci.upper = est + qnorm(0.975) * ste)
## save results
write.csv(res, "derived-data/SDMT-results/res.csv", row.names = F)
###############################################################################
###############################################################################
# Fake ENROLL-HD Data Analysis with cUHDRS Outcome
# Brian Richardson
# 2025-08-26
###############################################################################
###############################################################################
# setup -------------------------------------------------------------------
rm(list = ls())
library(dplyr)
library(ggplot2)
library(devtools)
library(fitdistrplus)
library(MASS)
library(tictoc)
library(statmod)
library(here)
setwd(here())
load_all(paste0(dirname(getwd()), "/sparcc"))
# load data ---------------------------------------------------------------
datf <- read.csv("derived-data/datf_cuhdrs.csv")
dat <- read.csv("derived-data/dat_cuhdrs.csv")
# estimate nuisance distributions -----------------------------------------
zs <- sort(unique(dat$Z)) # unique z values
mx <- 50                  # grid size for X
mc <- 50                  # grid size for C
my <- 5                   # grid size for Y
m.knots <- 5              # number of knots in spline models
Boundary.knots <- c(0, 1) # boundary knots for spline models
deg <- 3                  # degree of spline models
## X|Z quadrature nodes
x.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mx),
FUN = function(z) seq(1E-6, 1-1E-6, length = mx))
## X|Z modeled as conditional gamma
x.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
est <- dat %>%
filter(Z == z) %>%
mutate(left = W,
right = ifelse(Delta == 1, W, NA)) %>%
dplyr::select(left, right) %>%
as.data.frame() %>%
fitdistcens(distr = "beta")
return(est$estimate)
}))
eta1.param <- function(x, z) {
dbeta(x = x,
shape1 = x.params.hat[z + 1, "shape1"],
shape2 = x.params.hat[z + 1, "shape2"])
}
x.wts.param <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1.param(x.nds[,i], zs[i]) /
sum(eta1.param(x.nds[,i], zs[i])))
## nonparametric estimated distribution of X|Z (using B-splines)
tic("Spline fit X")
spline.res.x <- fit.spline(dat = dat, m.knots = m.knots,
Boundary.knots = Boundary.knots, deg = deg)
toc()
eta1.nonpar <- spline.res.x$dens
theta.hat.x <- spline.res.x$theta
knots.x <- spline.res.x$knots
wts.x <- spline.res.x$wts
glogf <- spline.res.x$glogf
x.wts.nonpar <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1.nonpar(x.nds[,i], zs[i]) /
sum(eta1.nonpar(x.nds[,i], zs[i])))
## C|Z quadrature nodes
c.nds <- vapply(
X = zs,
FUN.VALUE = numeric(mc),
FUN = function(z) seq(1E-6, 1-1E-6, length = mc))
## C|Z modeled as conditional beta
c.params.hat <- t(vapply(
X = 0:1,
FUN.VALUE = numeric(2),
FUN = function(z) {
# NOTE: C is available for all subjects; no censoring
est <- datf %>%
filter(Z == z) %>%
dplyr::select(C) %>%
unlist() %>%
fitdist(distr = "beta")
return(est$estimate)
}))
eta2.param <- function(c, z) {
dbeta(x = c,
shape1 = c.params.hat[z + 1, "shape1"],
shape2 = c.params.hat[z + 1, "shape2"])
}
c.wts.param <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mc),
FUN = function(i) eta2.param(c.nds[,i], zs[i]) /
sum(eta2.param(c.nds[,i], zs[i])))
## nonparametric estimated distribution of C|Z (using B-splines)
tic("Spline fit C")
spline.res.c <- fit.spline(dat = mutate(dat, Delta = 1 - Delta),
m.knots = m.knots, Boundary.knots = Boundary.knots,
deg = deg)
toc()
eta2.nonpar <- spline.res.c$dens
c.wts.nonpar <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mc),
FUN = function(i) eta2.nonpar(c.nds[,i], zs[i]) /
sum(eta2.nonpar(c.nds[,i], zs[i])))
## Y|X,Z quadrature nodes
gq <- gauss.quad(n = my, kind = "hermite")
y.nds <- gq$nodes
y.wts <- gq$weights
# analysis ----------------------------------------------------------------
## complete case linear model to get starting value
cc.lm <- lm(Y ~ W * Z, data = filter(dat, Delta == 1))
summary(cc.lm)
## complete case
tic("CC estimate")
B.cc <- get.root(dat = dat, score = get.Scc,
args = list(xz.interaction = T),
start = c(cc.lm$coef, log(var(cc.lm$resid))))
toc()
tic("CC variance")
V.cc <- var.est.sand(dat = dat, theta = B.cc,
n = sum(dat$Delta),
list(xz.interaction = T),
get.S = get.Scc, return.se = F)
toc()
saveRDS(list(B = B.cc, V = V.cc),
file = "derived-data/cUHDRS-results/cc_res")
cbind(B.cc, sqrt(diag(V.cc)))
summary(cc.lm)$coefficients[,1:2]
## MLE
mle.args <- list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, x.wts = x.wts.param,
xz.interaction = T)
tic("MLE estimate")
B.ml <- get.root(dat = dat, score = get.Sml, start = B.cc,
args = mle.args)
toc()
tic("MLE variance")
V.ml <- var.est.sand(
dat = dat,
get.S = function(dat, theta, args, return.sums = F) {
# extract X|Z parameters
alpha <- matrix(tail(theta, -5), ncol = length(zs))
# define estimated X|Z density
eta1 <- function(x, z) {
dbeta(x = x,
shape1 = alpha[z + 1],
shape2 = alpha[z + 3])
}
# create quadrature nodes
x.wts <- vapply(
X = 1:length(zs),
FUN.VALUE = numeric(mx),
FUN = function(i) eta1(x.nds[,i], zs[i]) / sum(eta1(x.nds[,i], zs[i])))
args <- list(x.nds = x.nds, x.wts = x.wts, xz.interaction = T)
# stack estimating equations
S <- cbind(get.Sml(dat = dat, theta = head(theta, 5),
args = args, return.sums = F),
d.log.fxz(dat = dat, theta = alpha,
args = args, return.sums = F))
if (return.sums) {
return(colSums(S))
} else {
return(S)
}
},
theta = c(B.ml, x.params.hat),
args = list(),
return.se = F)
toc()
saveRDS(list(B = B.ml, V = V.ml),
file = "derived-data/cUHDRS-results/ml_res")
## semiparametric (X|Z, C|Z nonparametric)
sp.nonpar.args <- list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, c.nds = c.nds,
y.nds = y.nds, y.wts = y.wts,
x.wts = x.wts.nonpar,
c.wts = c.wts.nonpar,
eta1 = eta1.nonpar,
xz.interaction = T)
tic("SP (nonpar) estimate")
B.sp.nonpar <- get.root(dat = dat, score = get.Seff,
start = B.cc,
args = sp.nonpar.args)
toc()
tic("SP (nonpar) variance")
V.sp.nonpar <- var.est.sand(dat = dat, theta = B.sp.nonpar,
args = sp.nonpar.args,
get.S = get.Seff, return.se = F)
toc()
saveRDS(list(B = B.sp.nonpar, V = V.sp.nonpar),
file = "derived-data/cUHDRS-results/sp_nonpar_res")
## semiparametric (X|Z, C|Z parametric)
sp.param.args <- list(mu = mu, d.mu = d.mu, SF = SF, fy = fy,
x.nds = x.nds, c.nds = c.nds,
y.nds = y.nds, y.wts = y.wts,
x.wts = x.wts.param,
c.wts = c.wts.param,
eta1 = eta1.param,
xz.interaction = T)
tic("SP (param) estimate")
B.sp.param <- get.root(dat = dat, score = get.Seff,
start = B.sp.nonpar,
args = sp.param.args)
toc()
tic("SP (param) variance")
V.sp.param <- var.est.sand(dat = dat, theta = B.sp.param,
args = sp.param.args,
get.S = get.Seff, return.se = F)
toc()
saveRDS(list(B = B.sp.param, V = V.sp.param),
file = "derived-data/cUHDRS-results/sp_param_res")
## results
res <- data.frame(
est = c(B.cc, B.ml, B.sp.param, B.sp.nonpar),
ste = c(sqrt(diag(V.cc)), sqrt(diag(V.ml)[1:5]),
sqrt(diag(V.sp.param)), sqrt(diag(V.sp.nonpar))),
param = rep(1:5, times = 4),
method = rep(c("CC", "MLE", "Semipar. (Param.)", "Semipar. (Nonpar.)"),
each = 5)) %>%
mutate(ci.lower = est - qnorm(0.975) * ste,
ci.upper = est + qnorm(0.975) * ste)
## save results
write.csv(res, "derived-data/cUHDRS-results/res.csv", row.names = F)
rm(list = ls())
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra)
library(here)
setwd(here())
res.tms <- read.csv("derived-data/tms-results/res.csv")
res.sdmt <- read.csv("derived-data/sdmt-results/res.csv")
res.cuhdrs <- read.csv("derived-data/cUHDRS-results/res.csv")
dat <- read.csv("derived-data/dat_cuhdrs.csv")
res <- rbind(cbind(outcome = "TMS", res.tms),
cbind(outcome = "SDMT", res.sdmt),
cbind(outcome = "cUHDRS", res.cuhdrs)) %>%
mutate(Method = ifelse(method == "Semipar. (Param.)", "Semipar",
ifelse(method == "Semipar. (Nonpar.)", "Semipar",
ifelse(method == "MLE", "MLE", "CC"))),
Method = factor(Method, levels = c("Semipar", "MLE", "CC")),
nuisX = ifelse(method %in% c("Semipar. (Param.)", "MLE"), "Param",
ifelse(method == "Semipar. (Nonpar.)", "Nonpar", "-")),
nuisX = factor(nuisX, levels = c("Param", "Nonpar", "-")),
nuisC = ifelse(method == "Semipar. (Param.)", "Param",
ifelse(method == "Semipar. (Nonpar.)", "Nonpar", "-")),
nuisC = factor(nuisC, levels = c("Param", "Nonpar", "-")),
outcome = factor(outcome, levels = c("TMS", "SDMT", "cUHDRS")))
# underscore (\u2081) not working in plot
param.labs <- c("\u03B21", "\u03B22", "\u03B23", "\u03B24", "log\u03C3\u00B2")
names(param.labs) <- 1:5
method.labs <- c("SPARCC (Param)", "SPARCC (Nonpar)", "MLE", "CC")
names(method.labs) <- c("sp_param", "sp_nonpar", "ml", "cc")
## Plot estimates and CIs
ggplot(
data = res,
aes(x = method,
y = est,
ymin = ci.lower,
ymax = ci.upper,
color = method)) +
geom_point() +
geom_errorbar() +
facet_grid(outcome ~ param,
labeller = labeller(param = param.labs),
scales = "free_y") +
labs(y = "Estimate with 95% CI",
color = "Method") +
ggtitle("ENROLL-HD Analysis Results",
subtitle = "Outcome ~ (Time to Diagnosis) + CAP Category") +
theme_bw() +
theme(legend.position = "bottom",
axis.title.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank())
## Table of results
tbl1 <- res %>%
mutate(ci = paste0("(", round(ci.lower, 2),
", ", round(ci.upper, 2), ")")) %>%
dplyr::select(outcome, param, Method, nuisX, nuisC, est, ste, ci) %>%
arrange(outcome, param, Method, nuisX) %>%
mutate_if(is.numeric, function(x) round(x, 2))
tbl1 %>%
kable(format = "latex",
digits = 2,
align = c(rep("c", 4),
rep("r", 3)),
booktabs = TRUE,
linesep = c("", "", "", "\\addlinespace\\hline"),
escape = FALSE,
col.names = c("Outcome", "Parameter", "Method", "X|Z", "C|Z",
"Estimate", "Std Error", "95% CI")) %>%
kable_styling("striped") %>%
row_spec(row = 0, bold = TRUE)
## Table of results with all params and with est(se) only
tbl2 <- res %>%
mutate(sig = ifelse(abs(est / ste) > qnorm(0.975), "*", ""),
est.ste = paste0(formatC(est, format = "f", digits = 2), "(",
formatC(ste, format = "f", digits = 2), ")",
sig)) %>%
dplyr::select(outcome, Method, nuisX, nuisC, param, est.ste) %>%
pivot_wider(values_from = est.ste,
names_from = param,
id_cols = c(outcome, Method, nuisX, nuisC))
tbl2 %>%
kable(format = "latex",
digits = 2,
align = c(rep("c", 4),
rep("r", 5)),
booktabs = TRUE,
linesep = c("", "", "", "\\addlinespace\\hline"),
escape = FALSE,
col.names = c("Outcome", "Estimator", "X|Z", "C|Z",
"beta_1", "beta_2", "beta_3",
"beta_4", "log(sigma2)")) %>%
add_header_above(c(" " = 4,
"Est(Std Error)" = 5)) %>%
kable_styling("striped") %>%
row_spec(row = 0, bold = TRUE)
## get predicted values over range of X values
len.new <- 100
Xnew <- data.frame(
int = 1,
X = seq(min(dat$W), max(dat$W), length = len.new),
Z = rep(0:1, each = len.new)) %>%
mutate(XZ = X * Z) %>%
as.matrix()
Yhats <- do.call(rbind, lapply(
unique(res$outcome),
function(outcome) {
Yhat.list <- lapply(
names(method.labs),
function(m) {
BV <- readRDS(paste0("derived-data/", outcome,
"-results/", m, "_res"))
B <- BV$B[1:4]; V <- BV$V[1:4, 1:4]
g <- ifelse(outcome == "TMS",
function(x) exp(x) - 1,
function(x) x)
Yhat <- Xnew %*% B
Yhat.se <- sqrt(diag(Xnew %*% V %*% t(Xnew)))
pred <- data.frame(
method = m,
int = Xnew[,1],
X = Xnew[,2],
Z = factor(Xnew[,3]),
Yhat = g(Yhat),
Ylower = g(Yhat - qnorm(0.975) * Yhat.se),
Yupper = g(Yhat + qnorm(0.975) * Yhat.se)
)
})
return(cbind(outcome = outcome, do.call(rbind, Yhat.list)))
})) %>%
mutate(Xscaled = (X * (2796.01 - 17.99) + 17.99) / 365,
Z = factor(Z,
levels = 0:1,
labels = c("Low-Medium", "High")),
method = factor(method,
levels = c("sp_param", "sp_nonpar", "ml", "cc")))
## plot fitted lines and 95% confidence intervals
ggplot(data = Yhats,
aes(x = Xscaled,
y = Yhat,
ymin = Ylower,
ymax = Yupper,
color = Z,
fill = Z)) +
geom_line() +
geom_ribbon(alpha = 0.5) +
facet_grid(outcome ~ method,
scales = "free",
labeller = labeller(method = method.labs)) +
theme_bw() +
scale_x_reverse() +
labs(y = "Estimated Mean Outcome (and 95% Confidence Interval)",
x = "Years Until Diagnosis",
color = "CAP Score:",
fill = "CAP Score:") +
theme(legend.position = "bottom")
ggsave("figures/analysis_fig1.png", dpi = 300, width = 6, height = 6)
## plot fitted lines and 95% confidence intervals for cUHDRS only
Yhats %>%
filter(outcome == "cUHDRS") %>%
mutate(method = factor(
method,
levels = c("cc", "ml", "sp_param", "sp_nonpar"),
labels = c("Complete Case", "MLE", "SPARCC (Param)", "SPARCC (Nonpar)"))) %>%
ggplot(
aes(x = Xscaled,
y = Yhat,
ymin = Ylower,
ymax = Yupper,
color = Z,
fill = Z)) +
geom_line() +
geom_ribbon(alpha = 0.5) +
facet_grid(~ method,
scales = "free") +
theme_bw() +
scale_x_reverse() +
labs(y = "cUHDRS",
x = "Years Until Diagnosis",
color = "CAP Score:",
fill = "CAP Score:") +
theme(legend.position = "bottom")
ggsave("figures/analysis_fig2.png", dpi = 300, width = 6, height = 3)
